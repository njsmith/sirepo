
#prevent GIST from starting upon setup
wp.top.lprntpara = False
wp.top.lpsplots = False

wp.top.verbosity = 0 # Reduce solver verbosity
solverE.mgverbose = 0 #further reduce output upon stepping - prevents websocket timeouts in Jupyter notebook
solverE.mgmaxiters = 12000 #rough approximation needed for initial solve to converge
wp.package("w3d")
wp.generate()
solverE.mgmaxiters = 100

import time

def analyze_scraped_particles2(top, particles, conductors):
    # reworked ConductorDiagnostics.analyze_scraped_particles
    # to pass in full conductor list, not just the ones registered with the solver
    cond_ids = []
    cond_objs = []
    lost = {}
    for cond in conductors:
        cond_objs.append(cond)
        cond_ids.append(cond.condid)

    for i, ids in enumerate(cond_ids):
        lost[ids] = np.copy(cond_objs[i].lostparticles_data[:, 0:2])
        lost[ids][:, 0] = np.ndarray.astype(np.round(lost[ids][:, 0] / top.dt), 'int')
        lost[ids][:, 1] = np.round(-1. * lost[ids][:, 1] / particles.sw / constants.e)

    return lost


def get_lost_counts():
    scraper_record = analyze_scraped_particles2(wp.top, beam, scraper.conductors)
    if np.sum(scraper_record[1][:, 1]):
        print('WARNING: source had particles')
    plate_count = np.sum(scraper_record[2][:, 1])
    conductor_count = 0
    for idx in scraper_record:
        if idx <= 2:
            continue
        conductor_count += np.sum(scraper_record[idx][:, 1])
    return np.array([plate_count, conductor_count])


num_steps = {{ simulationGrid_num_steps }}
counts_0 = np.array([0, 0])
wp.step(num_steps)

counts_1 = get_lost_counts()
#assert np.sum(counts_1) > 0, 'no particles deposited on conductors'
if np.sum(counts_1) == 0:
    print('WARNING: no particles deposited on conductors in initial steps')
clock = 0
time1 = time.time()

target = {{ optimizer_tolerance }}
# in seconds
time_limit = {{ optimizer_timeLimit }}
end_time = time.time() + time_limit

tol = target + 1
while (tol > target) and (time.time() < end_time):
    wp.step(num_steps)
    counts_2 = get_lost_counts()
    accumulated_0 = counts_1 - counts_0
    accumulated_1 = counts_2 - counts_1
    if not accumulated_1[-1]:
        print('WARNING: no particles accumulated on conductor')
        continue
    print('accumulated_1: {}'.format(accumulated_1))
    collector_fraction_0 = accumulated_0[-1] / np.sum(accumulated_0)
    collector_fraction_1 = accumulated_1[-1] / np.sum(accumulated_1)
    tol = abs(collector_fraction_1 - collector_fraction_0) / collector_fraction_1
    print('tol, target: {}, {}'.format(tol, target))
    print('accum ratio: {}'.format(accumulated_1[0] / np.sum(accumulated_1)))
    counts_0, counts_1 = counts_1, counts_2

stats = (accumulated_0 + accumulated_1) / 2

total = np.sum(stats)
efficiency = stats[0] / total if total else 0
print('plate_count: {:.0f}\nconductor_count: {:.0f}\ntotal: {:.0f}\nefficiency: {}'.format(stats[0], stats[1], total, efficiency))
